using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace GetTempMailORG
{
    public class TempMail : IDisposable
    {
        public string? _baseUrl = "https://web2.temp-mail.org";
        private readonly HttpClient httpClient;
        private bool disposed = false;

        public TempMail()
        {
            var handler = new HttpClientHandler()
            {
                UseCookies = true
            };

            httpClient = new HttpClient(handler);
            
            // Mô phỏng Chrome browser thực tế
            httpClient.DefaultRequestHeaders.Clear();
            httpClient.DefaultRequestHeaders.Add("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36");
            httpClient.DefaultRequestHeaders.Add("Accept", "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8");
            httpClient.DefaultRequestHeaders.Add("Accept-Language", "en-US,en;q=0.9");
            httpClient.DefaultRequestHeaders.Add("Accept-Encoding", "gzip, deflate, br");
            httpClient.DefaultRequestHeaders.Add("DNT", "1");
            httpClient.DefaultRequestHeaders.Add("Connection", "keep-alive");
            httpClient.DefaultRequestHeaders.Add("Upgrade-Insecure-Requests", "1");
            httpClient.DefaultRequestHeaders.Add("Sec-Fetch-Dest", "document");
            httpClient.DefaultRequestHeaders.Add("Sec-Fetch-Mode", "navigate");
            httpClient.DefaultRequestHeaders.Add("Sec-Fetch-Site", "none");
            httpClient.DefaultRequestHeaders.Add("Sec-Fetch-User", "?1");
            httpClient.DefaultRequestHeaders.Add("sec-ch-ua", "\"Not_A Brand\";v=\"8\", \"Chromium\";v=\"120\", \"Google Chrome\";v=\"120\"");
            httpClient.DefaultRequestHeaders.Add("sec-ch-ua-mobile", "?0");
            httpClient.DefaultRequestHeaders.Add("sec-ch-ua-platform", "\"Windows\"");

            // Timeout để tránh bị Cloudflare block
            httpClient.Timeout = TimeSpan.FromSeconds(30);
        }

        public async Task<Mail?> GetMailAsync()
        {
            try
            {
                Console.WriteLine("Sending request to get mail...");
                
                // Thêm delay để tránh rate limiting
                await Task.Delay(1000);
                
                // Gửi GET request trước để lấy cookies/session từ Cloudflare
                Console.WriteLine("Getting initial page for cookies...");
                var initialResponse = await httpClient.GetAsync(_baseUrl);
                Console.WriteLine($"Initial request status: {initialResponse.StatusCode}");
                
                // Delay thêm chút
                await Task.Delay(2000);
                
                // Bây giờ gửi POST request để lấy mailbox
                Console.WriteLine("Sending POST request for mailbox...");
                var content = new FormUrlEncodedContent(new Dictionary<string, string>());
                HttpResponseMessage response = await httpClient.PostAsync($"{_baseUrl}/mailbox", content);
                
                Console.WriteLine($"POST Status Code: {response.StatusCode}");
                
                if (response.IsSuccessStatusCode)
                {
                    string html = await response.Content.ReadAsStringAsync();
                    Console.WriteLine($"Response Length: {html.Length}");
                    Console.WriteLine($"First 500 chars: {html.Substring(0, Math.Min(500, html.Length))}");
                    
                    string token = Regex.Match(html, "\"token\":\"(.*?)\"").Groups[1].Value;
                    string email = Regex.Match(html, "\"mailbox\":\"(.*?)\"").Groups[1].Value;
                    
                    Console.WriteLine($"Token found: {!string.IsNullOrEmpty(token)} - {token}");
                    Console.WriteLine($"Email found: {!string.IsNullOrEmpty(email)} - {email}");
                    
                    if (!string.IsNullOrEmpty(token) && !string.IsNullOrEmpty(email))
                    {
                        return new Mail { Token = token, Email = email };
                    }
                    
                    // Thử pattern khác
                    token = Regex.Match(html, @"token['"":]\s*['""]([^'""]+)['""]", RegexOptions.IgnoreCase).Groups[1].Value;
                    email = Regex.Match(html, @"mailbox['"":]\s*['""]([^'""]+)['""]", RegexOptions.IgnoreCase).Groups[1].Value;
                    
                    Console.WriteLine($"Alternative token found: {!string.IsNullOrEmpty(token)} - {token}");
                    Console.WriteLine($"Alternative email found: {!string.IsNullOrEmpty(email)} - {email}");
                    
                    if (!string.IsNullOrEmpty(token) && !string.IsNullOrEmpty(email))
                    {
                        return new Mail { Token = token, Email = email };
                    }
                }
                else
                {
                    string errorContent = await response.Content.ReadAsStringAsync();
                    Console.WriteLine($"Error response: {errorContent}");
                    
                    // Kiểm tra xem có phải Cloudflare challenge không
                    if (errorContent.Contains("Checking your browser") || 
                        errorContent.Contains("cloudflare") || 
                        response.StatusCode == System.Net.HttpStatusCode.Forbidden ||
                        response.StatusCode == System.Net.HttpStatusCode.ServiceUnavailable)
                    {
                        Console.WriteLine("Detected Cloudflare challenge!");
                        throw new Exception("Cloudflare protection detected. Try using a different approach or add more delays.");
                    }
                }
            }
            catch (HttpRequestException ex)
            {
                Console.WriteLine($"HTTP Exception in GetMailAsync: {ex.Message}");
                throw;
            }
            catch (TaskCanceledException ex)
            {
                Console.WriteLine($"Timeout Exception in GetMailAsync: {ex.Message}");
                throw new Exception("Request timed out - possible Cloudflare blocking");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Exception in GetMailAsync: {ex.Message}");
                Console.WriteLine($"Exception stack trace: {ex.StackTrace}");
                throw;
            }
            return null;
        }

        public async Task<string?> GetOTPAsync(string _token)
        {
            string? code = "";
            
            // Clear và set authorization header
            httpClient.DefaultRequestHeaders.Authorization = null;
            httpClient.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", _token ?? "");
            
            for (int i = 0; i < 10; i++)
            {
                try
                {
                    Console.WriteLine($"Getting OTP attempt {i + 1}...");
                    await Task.Delay(5000); // Delay trước mỗi request
                    
                    HttpResponseMessage response = await httpClient.GetAsync($"{_baseUrl}/messages");
                    Console.WriteLine($"GetOTP attempt {i + 1}, Status: {response.StatusCode}");
                    
                    if (response.IsSuccessStatusCode)
                    {
                        string html = await response.Content.ReadAsStringAsync();
                        Console.WriteLine($"Messages response length: {html.Length}");
                        
                        string otp = Regex.Match(html, "Your OTP is: (.*?)</p>").Groups[1].Value;
                        if (!string.IsNullOrEmpty(otp))
                        {
                            Console.WriteLine($"OTP found: {otp}");
                            return otp;
                        }
                        
                        // Thử pattern khác
                        otp = Regex.Match(html, @"OTP[:\s]*(\d+)", RegexOptions.IgnoreCase).Groups[1].Value;
                        if (!string.IsNullOrEmpty(otp))
                        {
                            Console.WriteLine($"Alternative OTP found: {otp}");
                            return otp;
                        }
                        
                        Console.WriteLine($"No OTP found in attempt {i + 1}");
                    }
                    else
                    {
                        string errorContent = await response.Content.ReadAsStringAsync();
                        Console.WriteLine($"GetOTP error response: {errorContent}");
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Exception in GetOTPAsync attempt {i + 1}: {ex.Message}");
                }
            }
            return code;
        }

        // Synchronous wrapper methods for backward compatibility
        public Mail? GetMail()
        {
            return GetMailAsync().GetAwaiter().GetResult();
        }

        public string? GetOTP(string _token)
        {
            return GetOTPAsync(_token).GetAwaiter().GetResult();
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (!disposed)
            {
                if (disposing)
                {
                    httpClient?.Dispose();
                }
                disposed = true;
            }
        }

        public class Mail
        {
            public string? Token { get; set; }
            public string? Email { get; set; }
        }
    }
}