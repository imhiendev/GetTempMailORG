using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Net;

namespace GetTempMailORG
{
    public class TempMail : IDisposable
    {
        public string? _baseUrl = "https://web2.temp-mail.org";
        private readonly HttpClient httpClient;
        private readonly CookieContainer cookieContainer;
        private bool disposed = false;

        public TempMail()
        {
            cookieContainer = new CookieContainer();
            
            var handler = new HttpClientHandler()
            {
                CookieContainer = cookieContainer,
                UseCookies = true,
                UseDefaultCredentials = false,
                // Thêm SSL/TLS settings
                ServerCertificateCustomValidationCallback = (sender, cert, chain, sslPolicyErrors) => true
            };

            httpClient = new HttpClient(handler);
            
            // Headers minimal như curl hoặc simple client
            httpClient.DefaultRequestHeaders.Clear();
            httpClient.DefaultRequestHeaders.Add("User-Agent", "curl/7.68.0");
            httpClient.DefaultRequestHeaders.Add("Accept", "*/*");
            httpClient.DefaultRequestHeaders.Add("Connection", "keep-alive");

            httpClient.Timeout = TimeSpan.FromSeconds(60);
        }

        public async Task<Mail?> GetMailAsync()
        {
            try
            {
                Console.WriteLine("Trying simple curl-like request...");
                
                // Thử với headers minimal như curl
                HttpResponseMessage response = await httpClient.PostAsync($"{_baseUrl}/mailbox", null);
                
                Console.WriteLine($"Status Code: {response.StatusCode}");
                
                if (response.StatusCode == HttpStatusCode.Forbidden)
                {
                    Console.WriteLine("Got 403, trying different approach...");
                    return await TryAlternativeApproach();
                }
                
                if (response.IsSuccessStatusCode)
                {
                    string html = await response.Content.ReadAsStringAsync();
                    Console.WriteLine($"Response Length: {html.Length}");
                    Console.WriteLine($"First 300 chars: {html.Substring(0, Math.Min(300, html.Length))}");
                    
                    return ExtractMailData(html);
                }
                else
                {
                    string errorContent = await response.Content.ReadAsStringAsync();
                    Console.WriteLine($"Error response: {errorContent}");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Exception in GetMailAsync: {ex.Message}");
                return await TryAlternativeApproach();
            }
            return null;
        }

        private async Task<Mail?> TryAlternativeApproach()
        {
            try
            {
                Console.WriteLine("Trying alternative headers...");
                
                // Clear headers và thử với headers khác
                httpClient.DefaultRequestHeaders.Clear();
                httpClient.DefaultRequestHeaders.Add("User-Agent", "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2)");
                httpClient.DefaultRequestHeaders.Add("Accept", "application/json, text/plain, */*");
                httpClient.DefaultRequestHeaders.Add("Accept-Language", "en-US,en;q=0.5");
                httpClient.DefaultRequestHeaders.Add("Cache-Control", "no-cache");
                httpClient.DefaultRequestHeaders.Add("Pragma", "no-cache");
                
                await Task.Delay(3000); // Delay longer
                
                // Thử với empty form data
                var formData = new List<KeyValuePair<string, string>>();
                var formContent = new FormUrlEncodedContent(formData);
                
                HttpResponseMessage response = await httpClient.PostAsync($"{_baseUrl}/mailbox", formContent);
                Console.WriteLine($"Alternative approach status: {response.StatusCode}");
                
                if (response.IsSuccessStatusCode)
                {
                    string html = await response.Content.ReadAsStringAsync();
                    Console.WriteLine($"Alternative response length: {html.Length}");
                    return ExtractMailData(html);
                }
                else if (response.StatusCode == HttpStatusCode.Forbidden)
                {
                    Console.WriteLine("Still getting 403, trying Postman simulation...");
                    return await TryPostmanSimulation();
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Alternative approach failed: {ex.Message}");
                return await TryPostmanSimulation();
            }
            return null;
        }

        private async Task<Mail?> TryPostmanSimulation()
        {
            try
            {
                Console.WriteLine("Trying Postman-like simulation...");
                
                // Reset headers để giống Postman
                httpClient.DefaultRequestHeaders.Clear();
                httpClient.DefaultRequestHeaders.Add("User-Agent", "PostmanRuntime/7.32.3");
                httpClient.DefaultRequestHeaders.Add("Accept", "*/*");
                httpClient.DefaultRequestHeaders.Add("Accept-Encoding", "gzip, deflate, br");
                httpClient.DefaultRequestHeaders.Add("Connection", "keep-alive");
                
                await Task.Delay(2000);
                
                // Tạo content như Postman gửi
                var content = new StringContent("", Encoding.UTF8, "application/x-www-form-urlencoded");
                
                HttpResponseMessage response = await httpClient.PostAsync($"{_baseUrl}/mailbox", content);
                Console.WriteLine($"Postman simulation status: {response.StatusCode}");
                
                if (response.IsSuccessStatusCode)
                {
                    string html = await response.Content.ReadAsStringAsync();
                    Console.WriteLine($"Postman simulation response length: {html.Length}");
                    return ExtractMailData(html);
                }
                else
                {
                    string errorContent = await response.Content.ReadAsStringAsync();
                    Console.WriteLine($"Postman simulation error: {errorContent}");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Postman simulation failed: {ex.Message}");
            }
            return null;
        }

        private Mail? ExtractMailData(string html)
        {
            try
            {
                // Thử nhiều pattern khác nhau
                string token = Regex.Match(html, "\"token\":\"(.*?)\"").Groups[1].Value;
                string email = Regex.Match(html, "\"mailbox\":\"(.*?)\"").Groups[1].Value;
                
                Console.WriteLine($"Token found: {!string.IsNullOrEmpty(token)} - {token}");
                Console.WriteLine($"Email found: {!string.IsNullOrEmpty(email)} - {email}");
                
                if (!string.IsNullOrEmpty(token) && !string.IsNullOrEmpty(email))
                {
                    return new Mail { Token = token, Email = email };
                }
                
                // Pattern khác
                token = Regex.Match(html, @"token['"":]\s*['""]([^'""]+)['""]", RegexOptions.IgnoreCase).Groups[1].Value;
                email = Regex.Match(html, @"mailbox['"":]\s*['""]([^'""]+)['""]", RegexOptions.IgnoreCase).Groups[1].Value;
                
                if (!string.IsNullOrEmpty(token) && !string.IsNullOrEmpty(email))
                {
                    return new Mail { Token = token, Email = email };
                }
                
                // Pattern cho data attributes
                token = Regex.Match(html, @"data-token=['""]([^'""]+)['""]", RegexOptions.IgnoreCase).Groups[1].Value;
                email = Regex.Match(html, @"data-email=['""]([^'""]+)['""]", RegexOptions.IgnoreCase).Groups[1].Value;
                
                if (!string.IsNullOrEmpty(token) && !string.IsNullOrEmpty(email))
                {
                    return new Mail { Token = token, Email = email };
                }
                
                Console.WriteLine("No token/email found with any pattern");
                
                // In ra một phần HTML để debug
                if (html.Length > 1000)
                {
                    Console.WriteLine($"HTML sample: {html.Substring(500, 500)}");
                }
                
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error extracting mail data: {ex.Message}");
            }
            return null;
        }

        public async Task<string?> GetOTPAsync(string _token)
        {
            if (string.IsNullOrEmpty(_token))
                return null;
                
            // Set authorization header
            httpClient.DefaultRequestHeaders.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", _token);
            
            for (int i = 0; i < 10; i++)
            {
                try
                {
                    Console.WriteLine($"Getting OTP attempt {i + 1}...");
                    await Task.Delay(5000);
                    
                    HttpResponseMessage response = await httpClient.GetAsync($"{_baseUrl}/messages");
                    Console.WriteLine($"GetOTP attempt {i + 1}, Status: {response.StatusCode}");
                    
                    if (response.IsSuccessStatusCode)
                    {
                        string html = await response.Content.ReadAsStringAsync();
                        Console.WriteLine($"Messages response length: {html.Length}");
                        
                        // Thử nhiều pattern cho OTP
                        string[] otpPatterns = {
                            @"Your OTP is: (.*?)</p>",
                            @"OTP[:\s]*(\d+)",
                            @"verification code[:\s]*(\d+)",
                            @"code[:\s]*(\d{4,8})",
                            @"\b(\d{4,8})\b"
                        };
                        
                        foreach (var pattern in otpPatterns)
                        {
                            string otp = Regex.Match(html, pattern, RegexOptions.IgnoreCase).Groups[1].Value;
                            if (!string.IsNullOrEmpty(otp) && otp.All(char.IsDigit) && otp.Length >= 4)
                            {
                                Console.WriteLine($"OTP found with pattern '{pattern}': {otp}");
                                return otp;
                            }
                        }
                        
                        Console.WriteLine($"No OTP found in attempt {i + 1}");
                        
                        // Debug: In ra content để xem cấu trúc
                        if (i == 0 && html.Length > 0)
                        {
                            Console.WriteLine($"Sample messages content: {html.Substring(0, Math.Min(500, html.Length))}");
                        }
                    }
                    else
                    {
                        string errorContent = await response.Content.ReadAsStringAsync();
                        Console.WriteLine($"GetOTP error response: {errorContent}");
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Exception in GetOTPAsync attempt {i + 1}: {ex.Message}");
                }
            }
            return null;
        }

        // Synchronous wrapper methods for backward compatibility
        public Mail? GetMail()
        {
            return GetMailAsync().GetAwaiter().GetResult();
        }

        public string? GetOTP(string _token)
        {
            return GetOTPAsync(_token).GetAwaiter().GetResult();
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        protected virtual void Dispose(bool disposing)
        {
            if (!disposed)
            {
                if (disposing)
                {
                    httpClient?.Dispose();
                }
                disposed = true;
            }
        }

        public class Mail
        {
            public string? Token { get; set; }
            public string? Email { get; set; }
        }
    }
}