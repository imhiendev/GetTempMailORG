using System;
using System.IO;
using System.Net.Sockets;
using System.Net.Security;
using System.Security.Authentication;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Linq;
using System.IO.Compression;

namespace GetTempMailORG
{
    public class TlsClient : IDisposable
    {
        private readonly string _host;
        private readonly JA3Fingerprint _ja3Fingerprint;
        private readonly int _port;
        private readonly TcpClient _tcpClient;
        private SslStream _sslStream;
        private readonly string proxyString;
        private bool disposed = false;

        public TlsClient(string host, int port = 443, JA3Fingerprint ja3Fingerprint = null, string proxyString = null)
        {
            _host = host;
            _port = port;
            _ja3Fingerprint = ja3Fingerprint ?? JA3Fingerprint.Default;
            this.proxyString = proxyString;
            _tcpClient = new TcpClient();
        }

        public void Dispose()
        {
            if (!disposed)
            {
                _sslStream?.Dispose();
                _tcpClient?.Dispose();
                disposed = true;
            }
        }

        public async Task<string> SendRequestAsync(string request, TimeSpan timeout)
        {
            try
            {
                await EstablishConnection(timeout);
                
                var requestBytes = Encoding.UTF8.GetBytes(request);
                await _sslStream.WriteAsync(requestBytes, 0, requestBytes.Length);
                await _sslStream.FlushAsync();

                return await ReadHttpResponseAsync(timeout);
            }
            catch (Exception ex)
            {
                throw new Exception($"TLS request failed: {ex.Message}", ex);
            }
        }

        private async Task EstablishConnection(TimeSpan timeout)
        {
            Stream baseStream;

            if (!string.IsNullOrWhiteSpace(proxyString))
            {
                baseStream = await ConnectViaProxy();
            }
            else
            {
                await _tcpClient.ConnectAsync(_host, _port);
                baseStream = _tcpClient.GetStream();
            }

            _sslStream = new SslStream(baseStream, false, ServerCertificateCustomValidationCallback);
            var clientCertificates = new X509CertificateCollection();
            var applicationProtocols = _ja3Fingerprint.GetApplicationProtocols()
                .Select(p => new SslApplicationProtocol(Encoding.UTF8.GetBytes(p)))
                .ToList();

            var sslClientAuthenticationOptions = new SslClientAuthenticationOptions
            {
                TargetHost = _host,
                ClientCertificates = clientCertificates,
                EnabledSslProtocols = _ja3Fingerprint.GetSslProtocols(),
                ApplicationProtocols = applicationProtocols,
                EncryptionPolicy = EncryptionPolicy.RequireEncryption
            };

            using var cts = new CancellationTokenSource(timeout);
            await _sslStream.AuthenticateAsClientAsync(sslClientAuthenticationOptions, cts.Token);
        }

        private async Task<Stream> ConnectViaProxy()
        {
            var parts = proxyString.Split(':');
            if (parts.Length < 2)
                throw new FormatException("Invalid proxy format. Expected ip:port[:user[:pass]]");

            var proxyHost = parts[0];
            var proxyPort = int.Parse(parts[1]);
            string? username = parts.Length > 2 ? parts[2] : null;
            string? password = parts.Length > 3 ? parts[3] : null;

            await _tcpClient.ConnectAsync(proxyHost, proxyPort);
            var baseStream = _tcpClient.GetStream();

            var sb = new StringBuilder();
            sb.AppendLine($"CONNECT {_host}:{_port} HTTP/1.1");
            sb.AppendLine($"Host: {_host}:{_port}");

            if (!string.IsNullOrEmpty(username) && !string.IsNullOrEmpty(password))
            {
                var credentials = Convert.ToBase64String(Encoding.ASCII.GetBytes($"{username}:{password}"));
                sb.AppendLine($"Proxy-Authorization: Basic {credentials}");
            }

            sb.AppendLine();
            var connectRequest = sb.ToString();
            var connectRequestBytes = Encoding.ASCII.GetBytes(connectRequest);
            await baseStream.WriteAsync(connectRequestBytes, 0, connectRequestBytes.Length);

            using var proxyReader = new StreamReader(baseStream, Encoding.ASCII, false, leaveOpen: true);
            string proxyLine;
            bool success = false;
            while (!string.IsNullOrWhiteSpace(proxyLine = await proxyReader.ReadLineAsync()))
            {
                if (proxyLine.StartsWith("HTTP/1.1 200") || proxyLine.StartsWith("HTTP/1.0 200"))
                {
                    success = true;
                    break;
                }
                if (proxyLine.StartsWith("HTTP/1."))
                {
                    throw new Exception($"Proxy CONNECT failed: {proxyLine}");
                }
            }

            if (!success)
                throw new Exception("Proxy CONNECT tunnel failed.");

            return baseStream;
        }

        private async Task<string> ReadHttpResponseAsync(TimeSpan timeout)
        {
            using var cts = new CancellationTokenSource(timeout);
            
            try
            {
                var rawResponse = await ReadRawBytesAsync(cts.Token);
                var responseString = await ProcessRawResponse(rawResponse);
                
                if (string.IsNullOrEmpty(responseString) || !responseString.StartsWith("HTTP/"))
                {
                    responseString = TryAlternativeEncodingDecoding(rawResponse);
                }
                
                return responseString;
            }
            catch (OperationCanceledException)
            {
                throw new TimeoutException("HTTP response reading timed out");
            }
        }

        private async Task<byte[]> ReadRawBytesAsync(CancellationToken cancellationToken)
        {
            using var memoryStream = new MemoryStream();
            var buffer = new byte[8192];
            var totalBytesRead = 0;
            var lastReadTime = DateTime.Now;
            
            while (!cancellationToken.IsCancellationRequested)
            {
                try
                {
                    var readTask = _sslStream.ReadAsync(buffer, 0, buffer.Length, cancellationToken);
                    var timeoutTask = Task.Delay(5000, cancellationToken);
                    
                    var completedTask = await Task.WhenAny(readTask, timeoutTask);
                    
                    if (completedTask == readTask)
                    {
                        var bytesRead = await readTask;
                        if (bytesRead > 0)
                        {
                            memoryStream.Write(buffer, 0, bytesRead);
                            totalBytesRead += bytesRead;
                            lastReadTime = DateTime.Now;
                        }
                        else
                        {
                            break;
                        }
                    }
                    else
                    {
                        if (totalBytesRead > 0 && DateTime.Now.Subtract(lastReadTime).TotalSeconds > 3)
                        {
                            break;
                        }
                    }
                }
                catch (Exception ex) when (!(ex is OperationCanceledException))
                {
                    break;
                }
            }
            
            return memoryStream.ToArray();
        }

        private async Task<string> ProcessRawResponse(byte[] rawBytes)
        {
            try
            {
                var responseString = Encoding.UTF8.GetString(rawBytes);
                var lines = responseString.Split(new[] { "\r\n", "\n" }, StringSplitOptions.None);
                
                bool contentIsCompressed = false;
                string compressionType = "";
                bool isChunked = false;
                int headerEndIndex = -1;
                
                for (int i = 0; i < lines.Length; i++)
                {
                    var line = lines[i];
                    if (string.IsNullOrEmpty(line))
                    {
                        headerEndIndex = i;
                        break;
                    }
                    
                    var lowerLine = line.ToLower();
                    if (lowerLine.StartsWith("content-encoding:"))
                    {
                        if (lowerLine.Contains("gzip"))
                        {
                            contentIsCompressed = true;
                            compressionType = "gzip";
                        }
                        else if (lowerLine.Contains("deflate"))
                        {
                            contentIsCompressed = true;
                            compressionType = "deflate";
                        }
                    }
                    else if (lowerLine.StartsWith("transfer-encoding:") && lowerLine.Contains("chunked"))
                    {
                        isChunked = true;
                    }
                }
                
                if (contentIsCompressed && headerEndIndex > -1)
                {
                    var bodyStartIndex = FindBodyStartIndex(rawBytes);
                    
                    if (bodyStartIndex > 0)
                    {
                        var headerText = Encoding.UTF8.GetString(rawBytes.Take(bodyStartIndex).ToArray());
                        var bodyBytes = rawBytes.Skip(bodyStartIndex).ToArray();
                        
                        if (isChunked)
                        {
                            bodyBytes = ProcessChunkedEncoding(bodyBytes);
                        }
                        
                        try
                        {
                            string decompressedBody = await TrySmartDecompression(bodyBytes, compressionType);
                            return headerText + decompressedBody;
                        }
                        catch
                        {
                            try
                            {
                                string decompressedBody = await TryAllDecompressionMethods(bodyBytes);
                                return headerText + decompressedBody;
                            }
                            catch
                            {
                                return headerText + Encoding.UTF8.GetString(bodyBytes);
                            }
                        }
                    }
                }

                return responseString.StartsWith("HTTP/") ? responseString : TryAlternativeEncodingDecoding(rawBytes);
            }
            catch (Exception)
            {
                return Encoding.UTF8.GetString(rawBytes);
            }
        }

        private int FindBodyStartIndex(byte[] rawBytes)
        {
            for (int i = 0; i < rawBytes.Length - 3; i++)
            {
                if (rawBytes[i] == 0x0D && rawBytes[i + 1] == 0x0A && 
                    rawBytes[i + 2] == 0x0D && rawBytes[i + 3] == 0x0A)
                {
                    return i + 4;
                }
            }
            
            for (int i = 0; i < rawBytes.Length - 1; i++)
            {
                if (rawBytes[i] == 0x0A && rawBytes[i + 1] == 0x0A)
                {
                    return i + 2;
                }
            }
            
            return -1;
        }

        private byte[] ProcessChunkedEncoding(byte[] chunkedData)
        {
            try
            {
                using var outputStream = new MemoryStream();
                int position = 0;
                
                while (position < chunkedData.Length)
                {
                    int lineEndPos = position;
                    while (lineEndPos < chunkedData.Length - 1)
                    {
                        if (chunkedData[lineEndPos] == 0x0D && chunkedData[lineEndPos + 1] == 0x0A)
                        {
                            break;
                        }
                        lineEndPos++;
                    }
                    
                    if (lineEndPos >= chunkedData.Length - 1) break;
                    
                    var chunkSizeBytes = chunkedData.Skip(position).Take(lineEndPos - position).ToArray();
                    var chunkSizeLine = Encoding.ASCII.GetString(chunkSizeBytes);
                    var chunkSizeHex = chunkSizeLine.Split(';')[0].Trim();
                    
                    if (!int.TryParse(chunkSizeHex, System.Globalization.NumberStyles.HexNumber, null, out int chunkSize))
                        break;
                    
                    if (chunkSize == 0) break;
                    
                    position = lineEndPos + 2;
                    
                    if (position + chunkSize > chunkedData.Length) break;
                    
                    var chunkData = chunkedData.Skip(position).Take(chunkSize).ToArray();
                    outputStream.Write(chunkData, 0, chunkSize);
                    
                    position += chunkSize;
                    
                    if (position < chunkedData.Length - 1 && 
                        chunkedData[position] == 0x0D && chunkedData[position + 1] == 0x0A)
                    {
                        position += 2;
                    }
                }
                
                return outputStream.ToArray();
            }
            catch
            {
                // Try to find gzip magic header manually
                for (int i = 0; i < chunkedData.Length - 1; i++)
                {
                    if (chunkedData[i] == 0x1F && chunkedData[i + 1] == 0x8B)
                    {
                        return chunkedData.Skip(i).ToArray();
                    }
                }
                
                return chunkedData;
            }
        }

        private async Task<string> TrySmartDecompression(byte[] bodyBytes, string compressionType)
        {
            if (compressionType == "gzip")
            {
                return await DecompressGzipSafe(bodyBytes);
            }
            else if (compressionType == "deflate")
            {
                return await DecompressDeflateSafe(bodyBytes);
            }
            
            return await TryAllDecompressionMethods(bodyBytes);
        }

        private async Task<string> DecompressGzipSafe(byte[] compressedData)
        {
            if (compressedData.Length < 10)
                throw new InvalidDataException("Data too short for gzip format");
            
            if (compressedData[0] != 0x1F || compressedData[1] != 0x8B)
                throw new InvalidDataException("Invalid gzip magic header");
            
            if (compressedData[2] != 0x08)
                throw new InvalidDataException("Unsupported gzip compression method");
            
            using var compressedStream = new MemoryStream(compressedData);
            using var gzipStream = new GZipStream(compressedStream, CompressionMode.Decompress);
            using var decompressedStream = new MemoryStream();
            
            await gzipStream.CopyToAsync(decompressedStream);
            return Encoding.UTF8.GetString(decompressedStream.ToArray());
        }

        private async Task<string> DecompressDeflateSafe(byte[] compressedData)
        {
            using var compressedStream = new MemoryStream(compressedData);
            using var deflateStream = new DeflateStream(compressedStream, CompressionMode.Decompress);
            using var decompressedStream = new MemoryStream();
            
            await deflateStream.CopyToAsync(decompressedStream);
            return Encoding.UTF8.GetString(decompressedStream.ToArray());
        }

        private async Task<string> TryAllDecompressionMethods(byte[] data)
        {
            // Try standard deflate
            try
            {
                using var compressedStream = new MemoryStream(data);
                using var deflateStream = new DeflateStream(compressedStream, CompressionMode.Decompress);
                using var decompressedStream = new MemoryStream();
                
                await deflateStream.CopyToAsync(decompressedStream);
                var result = Encoding.UTF8.GetString(decompressedStream.ToArray());
                
                if (result.Length > 0 && (result.Contains("<!") || result.Contains("{") || 
                    result.Contains("token") || result.Contains("mailbox")))
                {
                    return result;
                }
            }
            catch { }

            // Try raw deflate
            try
            {
                var rawData = data.Length > 2 ? data.Skip(2).ToArray() : data;
                using var compressedStream = new MemoryStream(rawData);
                using var deflateStream = new DeflateStream(compressedStream, CompressionMode.Decompress);
                using var decompressedStream = new MemoryStream();
                
                await deflateStream.CopyToAsync(decompressedStream);
                var result = Encoding.UTF8.GetString(decompressedStream.ToArray());
                
                if (result.Length > 0) return result;
            }
            catch { }

            // Try zlib deflate
            try
            {
                if (data.Length > 0 && data[0] == 0x78)
                {
                    using var compressedStream = new MemoryStream(data.Skip(2).ToArray());
                    using var deflateStream = new DeflateStream(compressedStream, CompressionMode.Decompress);
                    using var decompressedStream = new MemoryStream();
                    
                    await deflateStream.CopyToAsync(decompressedStream);
                    var result = Encoding.UTF8.GetString(decompressedStream.ToArray());
                    
                    if (result.Length > 0) return result;
                }
            }
            catch { }

            // Try gzip fallback
            try
            {
                using var compressedStream = new MemoryStream(data);
                using var gzipStream = new GZipStream(compressedStream, CompressionMode.Decompress);
                using var decompressedStream = new MemoryStream();
                
                await gzipStream.CopyToAsync(decompressedStream);
                var result = Encoding.UTF8.GetString(decompressedStream.ToArray());
                
                if (result.Length > 0) return result;
            }
            catch { }

            throw new Exception("All decompression methods failed");
        }

        private string TryAlternativeEncodingDecoding(byte[] rawBytes)
        {
            var encodings = new[]
            {
                Encoding.ASCII,
                Encoding.UTF8,
                Encoding.Unicode,
                Encoding.BigEndianUnicode,
                Encoding.UTF32
            };

            foreach (var encoding in encodings)
            {
                try
                {
                    var decoded = encoding.GetString(rawBytes);
                    if (decoded.Contains("HTTP/"))
                    {
                        var httpIndex = decoded.IndexOf("HTTP/");
                        return decoded.Substring(httpIndex);
                    }
                }
                catch
                {
                    continue;
                }
            }

            return BitConverter.ToString(rawBytes.Take(1000).ToArray()).Replace("-", " ");
        }

        private bool ServerCertificateCustomValidationCallback(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)
        {
            return true;
        }
    }
}
