using System;
using System.IO;
using System.Net.Sockets;
using System.Net.Security;
using System.Security.Authentication;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Linq;
using System.IO.Compression;

namespace GetTempMailORG
{
    public class TlsClient : IDisposable
    {
        private readonly string _host;
        private readonly JA3Fingerprint _ja3Fingerprint;
        private readonly int _port;
        private readonly TcpClient _tcpClient;
        private SslStream _sslStream;
        private readonly string proxyString;
        private bool disposed = false;

        public TlsClient(string host, int port = 443, JA3Fingerprint ja3Fingerprint = null, string proxyString = null)
        {
            _host = host;
            _port = port;
            _ja3Fingerprint = ja3Fingerprint ?? JA3Fingerprint.Default;
            this.proxyString = proxyString;
            _tcpClient = new TcpClient();
        }

        public void Dispose()
        {
            if (!disposed)
            {
                _sslStream?.Dispose();
                _tcpClient?.Dispose();
                disposed = true;
            }
        }

        public async Task<string> SendRequestAsync(string request, TimeSpan timeout)
        {
            try
            {
                await EstablishConnection(timeout);
                
                // Send HTTP request
                var requestBytes = Encoding.UTF8.GetBytes(request);
                await _sslStream.WriteAsync(requestBytes, 0, requestBytes.Length);
                await _sslStream.FlushAsync();

                // Read response with better handling
                return await ReadHttpResponseAsync(timeout);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"TlsClient detailed error: {ex.GetType().Name}: {ex.Message}");
                if (ex.InnerException != null)
                {
                    Console.WriteLine($"Inner exception: {ex.InnerException.Message}");
                }
                throw;
            }
        }

        private async Task EstablishConnection(TimeSpan timeout)
        {
            Stream baseStream;

            if (!string.IsNullOrWhiteSpace(proxyString))
            {
                baseStream = await ConnectViaProxy();
            }
            else
            {
                await _tcpClient.ConnectAsync(_host, _port);
                baseStream = _tcpClient.GetStream();
            }

            _sslStream = new SslStream(baseStream, false, ServerCertificateCustomValidationCallback);
            var clientCertificates = await GetClientCertificatesAsync();
            var applicationProtocols = _ja3Fingerprint.GetApplicationProtocols()
                .Select(p => new SslApplicationProtocol(Encoding.UTF8.GetBytes(p)))
                .ToList();

            var sslClientAuthenticationOptions = new SslClientAuthenticationOptions
            {
                TargetHost = _host,
                ClientCertificates = clientCertificates,
                EnabledSslProtocols = _ja3Fingerprint.GetSslProtocols(),
                ApplicationProtocols = applicationProtocols,
                EncryptionPolicy = EncryptionPolicy.RequireEncryption
            };

            using var cts = new CancellationTokenSource(timeout);
            await _sslStream.AuthenticateAsClientAsync(sslClientAuthenticationOptions, cts.Token);
        }

        private async Task<Stream> ConnectViaProxy()
        {
            var parts = proxyString.Split(':');
            if (parts.Length < 2)
                throw new FormatException("Invalid proxy format. Expected ip:port[:user[:pass]]");

            var proxyHost = parts[0];
            var proxyPort = int.Parse(parts[1]);
            string? username = parts.Length > 2 ? parts[2] : null;
            string? password = parts.Length > 3 ? parts[3] : null;

            await _tcpClient.ConnectAsync(proxyHost, proxyPort);
            var baseStream = _tcpClient.GetStream();

            var sb = new StringBuilder();
            sb.AppendLine($"CONNECT {_host}:{_port} HTTP/1.1");
            sb.AppendLine($"Host: {_host}:{_port}");

            if (!string.IsNullOrEmpty(username) && !string.IsNullOrEmpty(password))
            {
                var credentials = Convert.ToBase64String(Encoding.ASCII.GetBytes($"{username}:{password}"));
                sb.AppendLine($"Proxy-Authorization: Basic {credentials}");
            }

            sb.AppendLine();
            var connectRequest = sb.ToString();
            var connectRequestBytes = Encoding.ASCII.GetBytes(connectRequest);
            await baseStream.WriteAsync(connectRequestBytes, 0, connectRequestBytes.Length);

            using var proxyReader = new StreamReader(baseStream, Encoding.ASCII, false, leaveOpen: true);
            string proxyLine;
            bool success = false;
            while (!string.IsNullOrWhiteSpace(proxyLine = await proxyReader.ReadLineAsync()))
            {
                if (proxyLine.StartsWith("HTTP/1.1 200") || proxyLine.StartsWith("HTTP/1.0 200"))
                {
                    success = true;
                    break;
                }
                if (proxyLine.StartsWith("HTTP/1."))
                {
                    throw new Exception($"Proxy CONNECT failed: {proxyLine}");
                }
            }

            if (!success)
                throw new Exception("Proxy CONNECT tunnel failed.");

            return baseStream;
        }

        private async Task<string> ReadHttpResponseAsync(TimeSpan timeout)
        {
            using var cts = new CancellationTokenSource(timeout);
            
            try
            {
                // Read raw bytes first to handle any encoding issues
                var rawResponse = await ReadRawBytesAsync(cts.Token);
                
                // Try to detect and handle different encodings
                var responseString = await ProcessRawResponse(rawResponse);
                
                // Validate HTTP response format
                if (string.IsNullOrEmpty(responseString) || !responseString.StartsWith("HTTP/"))
                {
                    // Log raw bytes for debugging
                    var preview = rawResponse.Take(50).Select(b => b < 32 || b > 126 ? $"\\x{b:X2}" : ((char)b).ToString());
                    var previewString = string.Join("", preview);
                    Console.WriteLine($"Invalid HTTP response detected. First 50 bytes: {previewString}");
                    
                    // Try alternative decoding methods
                    responseString = await TryAlternativeDecoding(rawResponse);
                }
                
                return responseString;
            }
            catch (OperationCanceledException)
            {
                throw new TimeoutException("HTTP response reading timed out");
            }
        }

        private async Task<byte[]> ReadRawBytesAsync(CancellationToken cancellationToken)
        {
            using var memoryStream = new MemoryStream();
            var buffer = new byte[8192];
            var totalBytesRead = 0;
            var lastReadTime = DateTime.Now;
            
            while (!cancellationToken.IsCancellationRequested)
            {
                try
                {
                    // Use a shorter timeout for individual reads
                    var readTask = _sslStream.ReadAsync(buffer, 0, buffer.Length, cancellationToken);
                    var timeoutTask = Task.Delay(5000, cancellationToken);
                    
                    var completedTask = await Task.WhenAny(readTask, timeoutTask);
                    
                    if (completedTask == readTask)
                    {
                        var bytesRead = await readTask;
                        if (bytesRead > 0)
                        {
                            memoryStream.Write(buffer, 0, bytesRead);
                            totalBytesRead += bytesRead;
                            lastReadTime = DateTime.Now;
                        }
                        else
                        {
                            // No more data
                            break;
                        }
                    }
                    else
                    {
                        // Timeout - check if we have enough data
                        if (totalBytesRead > 0 && DateTime.Now.Subtract(lastReadTime).TotalSeconds > 3)
                        {
                            break; // Assume response is complete
                        }
                    }
                }
                catch (Exception ex) when (!(ex is OperationCanceledException))
                {
                    Console.WriteLine($"Read error: {ex.Message}");
                    break;
                }
            }
            
            return memoryStream.ToArray();
        }

        private async Task<string> ProcessRawResponse(byte[] rawBytes)
        {
            try
            {
                // Try UTF-8 first
                var response = Encoding.UTF8.GetString(rawBytes);
                if (response.StartsWith("HTTP/"))
                {
                    return response;
                }

                // Check if it's compressed
                if (rawBytes.Length > 2)
                {
                    // Check for gzip header (1f 8b)
                    if (rawBytes[0] == 0x1f && rawBytes[1] == 0x8b)
                    {
                        return await DecompressGzip(rawBytes);
                    }
                    
                    // Check for deflate or other compression
                    return await TryDecompression(rawBytes);
                }

                return Encoding.ASCII.GetString(rawBytes);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error processing raw response: {ex.Message}");
                return Encoding.ASCII.GetString(rawBytes);
            }
        }

        private async Task<string> DecompressGzip(byte[] compressedData)
        {
            try
            {
                using var compressedStream = new MemoryStream(compressedData);
                using var gzipStream = new GZipStream(compressedStream, CompressionMode.Decompress);
                using var decompressedStream = new MemoryStream();
                
                await gzipStream.CopyToAsync(decompressedStream);
                var decompressedBytes = decompressedStream.ToArray();
                
                return Encoding.UTF8.GetString(decompressedBytes);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Gzip decompression failed: {ex.Message}");
                return Encoding.UTF8.GetString(compressedData);
            }
        }

        private async Task<string> TryDecompression(byte[] data)
        {
            // Try deflate
            try
            {
                using var compressedStream = new MemoryStream(data);
                using var deflateStream = new DeflateStream(compressedStream, CompressionMode.Decompress);
                using var decompressedStream = new MemoryStream();
                
                await deflateStream.CopyToAsync(decompressedStream);
                var decompressedBytes = decompressedStream.ToArray();
                
                var result = Encoding.UTF8.GetString(decompressedBytes);
                if (result.StartsWith("HTTP/"))
                {
                    return result;
                }
            }
            catch
            {
                // Deflate failed, continue with other methods
            }

            return Encoding.UTF8.GetString(data);
        }

        private async Task<string> TryAlternativeDecoding(byte[] rawBytes)
        {
            var encodings = new []
            {
                Encoding.ASCII,
                Encoding.UTF8,
                Encoding.Unicode,
                Encoding.BigEndianUnicode,
                Encoding.UTF32
            };

            foreach (var encoding in encodings)
            {
                try
                {
                    var decoded = encoding.GetString(rawBytes);
                    if (decoded.Contains("HTTP/"))
                    {
                        var httpIndex = decoded.IndexOf("HTTP/");
                        return decoded.Substring(httpIndex);
                    }
                }
                catch
                {
                    continue;
                }
            }

            // Last resort - return as hex string for debugging
            return BitConverter.ToString(rawBytes.Take(1000).ToArray()).Replace("-", " ");
        }

        private async Task<X509CertificateCollection> GetClientCertificatesAsync()
        {
            var certificates = new X509CertificateCollection();
            return certificates;
        }

        private bool ServerCertificateCustomValidationCallback(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors)
        {
            return true; // Accept all certificates for bypass
        }
    }
}
